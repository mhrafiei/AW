import matplotlib
matplotlib.use('Agg')  # Use a non-GUI backend

from flask import Flask, request, render_template, url_for
import pandas as pd
import matplotlib.pyplot as plt
import os
import uuid
from utilities import *  # Contains RollingDefectAnalysis, generate_response_format, generate_content_openai
import shutil
import time

app = Flask(__name__)
app.secret_key = 'your_secret_key'  # Required for flashing messages if needed



@app.route('/')
def index():
    return render_template('upload.html')

@app.route('/upload', methods=['POST'])
def upload():
    # --- Validate Mandatory Inputs ---
    file = request.files.get('file')
    if not file or file.filename == '':
        error = "Please select a CSV file."
        return render_template('upload.html', error=error)
    
    required_fields = [
        'rpm', 'sampling_frequency', 
        'bpfi_frequency', 'bpfo_frequency', 
        'ftf_frequency', 'bsf_frequency', 'filter_type'
    ]
    missing_fields = [field for field in required_fields if not request.form.get(field)]
    if missing_fields:
        error = f"Please fill in the mandatory fields: {', '.join(missing_fields)}."
        return render_template('upload.html', error=error)
    
    # --- Process the CSV File ---
    try:
        file.seek(0)
        df = pd.read_csv(file)
        if len(df.columns) != 1:
            error = "Error: CSV file should contain exactly one column."
            return render_template('upload.html', error=error)
        
        csv_sum = df.iloc[:, 0].sum()

        # Create a static folder if it doesn't exist
        static_folder = os.path.join(app.root_path, 'static')
        os.makedirs(static_folder, exist_ok=True)

        # Generate a unique subfolder using uuid
        subfolder = str(uuid.uuid4())
        subfolder_path = os.path.join(static_folder, subfolder)
        os.makedirs(subfolder_path)
    except Exception as e:
        error = f"Error processing CSV file: {e}"
        return render_template('upload.html', error=error)
    
    # --- Process Signal & Filter Parameters ---
    try:
        rpm = int(request.form.get("rpm"))
        sampling_frequency = int(request.form.get("sampling_frequency"))
        bpfi_frequency = float(request.form.get("bpfi_frequency"))
        bpfo_frequency = float(request.form.get("bpfo_frequency"))
        ftf_frequency = float(request.form.get("ftf_frequency"))
        bsf_frequency = float(request.form.get("bsf_frequency"))
    except Exception as e:
        error = f"Error processing numerical parameters: {e}"
        return render_template('upload.html', error=error)

    filter_type = request.form.get("filter_type")
    use_decibel = (request.form.get("use_decibel") == "on")
    use_walch   = (request.form.get("use_walch") == "on")

    # Use a short project name derived from the UUID (first segment)
    project = subfolder.split('-')[0]
    config = {
        "signal": df.values.ravel(),
        "fs": sampling_frequency,
        "rpm": rpm,
        "bpfi": bpfi_frequency,
        "bpfo": bpfo_frequency,
        "ftf": ftf_frequency,
        "bsf": bsf_frequency,
        "title": project,
        "peak_dividant": 50,
        "use_walch": use_walch,
        "filter_type": filter_type,
        "root_folder": subfolder_path
    }
    
    # Create a RollingDefectAnalysis object (from utilities.py) and generate plots
    obj = RollingDefectAnalysis(**config)
    obj.plot_time(seconds=2, close=True)
    obj.plot_frequency(db=use_decibel, signal_type='raw', close=True)
    obj.plot_frequency(db=use_decibel, signal_type='filtered', close=True)
    obj.plot_frequency(db=use_decibel, signal_type='envelope', close=True)
    obj.plot_spectrogram(signal_type="raw", close=True)
    obj.plot_spectrogram(signal_type="filtered", close=True)
    obj.plot_spectrogram(signal_type="envelope", close=True)

    freq_information = obj.freq_peaks
    features = obj.extract_features()

    # Define image filenames (as generated by the analysis functions)
    image_filenames = [
        f"{project}_time_{'walch' if use_walch else 'rfft'}_{filter_type.lower()}.png",
        f"{project}_freq_{'walch' if use_walch else 'rfft'}_{filter_type.lower()}_raw.png",
        f"{project}_freq_{'walch' if use_walch else 'rfft'}_{filter_type.lower()}_filtered.png",
        f"{project}_freq_{'walch' if use_walch else 'rfft'}_{filter_type.lower()}_envelope.png",
        f"{project}_spectrogram_{'walch' if use_walch else 'rfft'}_{filter_type.lower()}_raw.png",
        f"{project}_spectrogram_{'walch' if use_walch else 'rfft'}_{filter_type.lower()}_filtered.png",
        f"{project}_spectrogram_{'walch' if use_walch else 'rfft'}_{filter_type.lower()}_envelope.png"
    ]
    
    image_urls = [f"{subfolder}/{filename}" for filename in image_filenames]

    # Compose the prompt for the OpenAI-based report generation
    system_prompt = "You are a helpful assistant, replying in json"
    user_prompt = f"""
    Vibration signals were recorded from a rotating machine at {rpm} RPM (i.e., ~{int(rpm/60)} Hz). 
    Given the following information, identify potential rolling element bearing defects.
    
    Characteristic defect frequencies:
    - BPFI: {np.round(bpfi_frequency * rpm/60, 2)} Hz
    - BPFO: {np.round(bpfo_frequency * rpm/60, 2)} Hz
    - FTF: {np.round(ftf_frequency * rpm/60, 2)} Hz
    - BSF: {np.round(bsf_frequency * rpm/60, 2)} Hz
    
    Sampling frequency: {sampling_frequency} Hz.
    Filter applied: {filter_type}.
    
    Extracted features:
    - RMS: {np.round(features['rms'], 2)}
    - Kurtosis: {np.round(features['kurtosis'], 2)}
    - Crest Factor: {np.round(features['crest_factor'], 2)}
    - Skew: {np.round(features['skew'], 2)}
    - Impulse: {np.round(features['impulse'], 2)}
    
    Frequency peaks for analysis of the main frequencies and harmonics and modulations:
    - Raw: [{round_freqs(freq_information['raw'])}]
    - Filtered: [{round_freqs(freq_information['filtered'])}]
    - Envelope: [{round_freqs(freq_information['envelope'])}]
    
    Provide a large one-paragraph analysis for each defect:
    - BPFI
    - BPFO
    - FTF
    - BSF

    Then, provide a summary paragraph of your findings.
    In your responses, include details about the signal extracted features, frequency peaks, harmonics, and modulations.
    Do not fabricate details; base your report solely on the provided data.
    """
    
    keys = ['BPFI', 'BPFO', 'FTF', 'BSF', 'Summary']
    response_format = generate_response_format(keys, [f"One paragraph analysis for {k}" for k in keys])
    temperature = 0.1

    report_json = generate_content_openai(
        user_prompt,
        model="gpt-4o",
        system_prompt=system_prompt,
        response_format=response_format,
        temperature=temperature
    )

    # Render the display page with the analysis report and generated images
    return render_template(
        'display.html',
        csv_sum=csv_sum,
        image_urls=image_urls,
        rms=features['rms'],
        kurtosis=features['kurtosis'],
        crest_factor=features['crest_factor'],
        skews=features['skew'],
        impulse=features['impulse'],
        bpfi_report=report_json['BPFI'],
        bpfo_report=report_json['BPFO'],
        ftf_report=report_json['FTF'],
        bsf_report=report_json['BSF'],
        summary_report=report_json['Summary'],
        rpm=rpm,
        sampling_frequency=sampling_frequency,
        bpfi_frequency=bpfi_frequency,
        bpfo_frequency=bpfo_frequency,
        ftf_frequency=ftf_frequency,
        bsf_frequency=bsf_frequency,
        filter_type=filter_type,
        use_decibel=use_decibel,
        use_walch=use_walch
    )

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080, debug=True)
